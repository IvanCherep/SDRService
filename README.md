Тестовое задание для Nexign.

Задача 1:
Напишите сервис, эмулирующий работу коммутатора, т.е. генерирующий CDR файлы.
Условия:
1. 1 CDR = 1 месяц. Тарифицируемый период в рамках задания - 1 год;
2. Данные в CDR идут не по порядку, т.е. записи по одному абоненту могут быть в разных частях файла;
3. Количество и длительность звонков определяется случайным образом;
4. Установленный список абонентов (не менее 10) хранится в локальной БД (h2);
5. После генерации CDR, данные о транзакциях пользователя помещаются в соседнюю таблицу этой БД.

Задача 2:
Данные полученные от CDR сервиса передать в сервис генерации UDR. Агрегировать данные по каждому абоненту в отчет.
Условия:
1. Данные можно брать только из CDR файла. БД с описанием транзакций – тестовая, и доступа к ней, в рамках задания нет.
2. Сгенерированные объекты отчета разместить в /reports. Шаблон имени: номер_месяц.json (79876543221_1.json);
3. Класс генератора должен содержать методы:
a. generateReport() – сохраняет все отчеты и выводит в консоль таблицу со всеми абонентами и итоговым временем звонков по всему тарифицируемому периоду каждого абонента;
b. generateReport(msisdn) – сохраняет все отчеты и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в каждом месяце;
c. generateReport(msisdn, month) – сохраняет отчет и выводит в консоль таблицу по одному абоненту и его итоговому времени звонков в указанном месяце.

Описание классов
1. **CallStats**: Этот класс представляет статистику звонков для конкретного абонента. Он содержит поле `totalTime`, которое хранит общую продолжительность звонков для данного абонента. Метод `addDuration` используется для добавления продолжительности каждого отдельного звонка к общей продолжительности. Метод `getTotalTime` возвращает общую продолжительность звонков.

2. **CDRGenerator**: Этот класс отвечает за генерацию CDR (Call Detail Record) файлов. В методе `generateCDRFile` создается новый файл и генерируется указанное количество записей в формате CDR. Каждая запись представляет собой случайно сгенерированный тип вызова, номер телефона, дату и время начала и окончания звонка. Генерация происходит в пределах одного года. Методы `getPhoneNumberFromDatabase` и `getRandomTimeWithinOneYear` используются для получения реальных номеров телефонов из базы данных и генерации случайного времени в пределах одного года соответственно.

3. **CDRReader**: Этот класс отвечает за чтение CDR файлов и агрегацию данных из них. Метод `readCDRFile` читает указанный CDR файл, анализирует каждую запись и агрегирует статистику звонков для каждого абонента. Результат агрегации представлен в виде карты, где ключ - номер телефона абонента, а значение - статистика звонков для этого абонента.

4. **DatabaseManager**: Этот класс отвечает за сохранение транзакций (звонков) в базу данных. Метод `saveTransaction` принимает номер телефона абонента, время начала и окончания звонка и сохраняет эту информацию в базу данных.

5. **Main**: Этот класс содержит метод `main`, который является точкой входа в приложение. В данном случае он используется для запуска генерации отчетов по умолчанию.

6. **SubscriberDatabase**: Этот класс представляет базу данных абонентов. Он хранит информацию о номерах телефонов абонентов. Методы `addSubscriber` и `getSubscriberData` используются для добавления и получения данных абонента соответственно.

7. **UDR**: Этот класс представляет отчет UDR (Usage Detail Record) для конкретного абонента. Он содержит информацию о номере телефона абонента и статистику входящих и исходящих звонков (объекты `CallStats`). Методы `addIncomingCall` и `addOutgoingCall` используются для добавления продолжительности входящих и исходящих звонков соответственно.

8. **UDRReportGenerator**: Этот класс отвечает за генерацию отчетов UDR. Методы `generateReport` используются для сохранения отчетов в формате JSON и вывода сводной информации о звонках для всех абонентов или для конкретного абонента.
